세션 제어 필터
=================================================================
# SessionManagementFilter
1. **세션 관리 :** 인증시 사용자의 세션정보를 등록, 조회, 삭제 등의 세션 이력을 관리   
2. **동시적 세션 제어 :** 동일 계정으로 접속이 허용되는 최대 세션 수 제한
3. **세션 고정 보호 :** 인증할 때마다 세션쿠키를 새로 발급하여 공격자의 쿠키 조작을 방지 
4. **세션 생성 정책 :** Always, If_Required, Never, Statless  

# ConcurrentSessionFilter
SessionManagementFilter 랑 연계를 해서 `동시적 세션 제어`를 한다.     

* 매 요청 마다 현재 사용자의 세션 만료 여부를 체크 한다.   
* 세션이 만료되었을 경우 즉시 만료 처리를 한다.   

ConcurrentSessionFilter는 매 요청 마다 현재 사용자의 세션 만료 여부를 체크 한다.   
그리고 세션이 만료되었을 경우 즉시 만료 처리를 하는 작업을 한다.    
   
```java
session.isExpired() == true
```
* 로그아웃 처리  
* 즉시 오류 페이지 응답(This session has been expired)    

![image](https://user-images.githubusercontent.com/50267433/129360515-23bc5282-c15c-4381-89ec-9ed437566845.png)

이미 로그인을 했고 동일 계정으로 또 다시 로그인을 한다고 가정을 한다.          
        
1. 새로운 사용자(브라우저)로 로그인을 시도한다.      
2. 최근 로그인 이력이 있기에 이전 세션을 만료시킨다.(session.expireNow())      
3. 이전 사용자(브라우저)로 다시 서버에 접속을 한다.         
4. ConcurrentSessionFilter 가 동작하여 세션이 만료되었는지 확인한다.          
5. **세션 만료를 확인하는 과정에서 SessionManagementFilter 안에서 실행된 세션 만료 설정을 참조한다.**           
6. 이전 사용자 세션이 만료 되었다는 것을 확인했기에 로그인/오류페이지 응답을 반환한다.       

## 전반적인 처리 과정 및 Session 관련 필터 동작 흐름 알아보기  
     
![image](https://user-images.githubusercontent.com/50267433/129361886-c012c49f-3aa6-4481-ae1c-42d5832a14c2.png)   

**첫 로그인 사용자**
1. 로그인을 시도하면 제일 처음 ConcurrentSessionControlAuthenticationStrategy를 호출한다.   
2. ConcurrentSessionControlAuthenticationStrategy는 세션 개수를 카운팅 및 제한하는 인스턴스다.   
3. 첫 로그인은 세션 갯수가 0 이기에 문제 없이 다음 ChangeSessionIdAuthenticationStrategy 로 흐름이 넘어간다.   
4. ChangeSessionIdAuthenticationStrategy는 세션 고정 보호를 기준으로 동작을 하는 인스턴스다.   
5. 기본값으로는 세션ID만 변경하지만, 첫 로그인이므로 새로운 세션 생성 및 로그인 ID를 발급해준다.(session.changeSessionId())   
6. RegisterSessionAuthenticationStrategy를 통해 생성된 세션 정보를 등록한다.    
7. 인증이 성공 된다.   

**두 번째 로그인 사용자**    
1. 로그인을 시도하면 제일 처음 ConcurrentSessionControlAuthenticationStrategy를 호출한다.
2. 전략에 따라 동작이 달라진다.   
    * **현재 사용자 인증 실패 :** 세션 갯수가 최대이므로 SessionAuthenticationException을 발생하여 인증을 실패시킨다.   
    * **이전 사용자 세션 만료 :** `seesion.expireNow()`를 호출하여 기존 로그인 세션을 만료시킨다.    
3. 이전 사용자 세션 만료 전략일 때, ChangeSessionIdAuthenticationStrategy 로 흐름을 넘긴다.    
4. 전략마다 다르지만 기본값 기준이고 두 번째 로그인이므로 세션ID만 변경한다.(session.changeSessionId())   
5. RegisterSessionAuthenticationStrategy를 통해 새로운 세션 정보를 등록한다.    

**첫 로그인 사용자 재접속**   
1. 이미 로그인 경험이 있기에 ConcurrentSessionFilter가 동작을 한다.   
2. ConcurrentSessionFilter는 세션 만료 여부를 확인하기위해 `isExpired()`를 실행한다.    
3. `isExpired()`는 이전 로그인 즉, SessionManagementFilter 에서 `expireNow()`가 실행되었는지 확인한다.     
4. `두 번째 로그인 사용자`로 인해 세션이 만료되었기에 `isExpired()`는 true를 리턴한다.     
5. ConcurrentSessionFilter는 로그아웃 처리및 에러를 응답한다.    
 
## 코드  
```java
public void onAuthentication(Authentication authentication, 
        HttpServletRequest request, HttpServletResponse response) {
    final List<SessionInformation> sessions = sessionRegistry.getAllSessions(
            authentication.getPrincipal(), false);
        int sessionCount = sessions.size();
        int allowedSessions = getMaximumSessionsForThisUser(authentication);
        if (sessionCount < allowedSessions) {
            // They haven't got too many login sessions running at present
            return;
	     }
        if (allowedSessions == -1) {
            // We permit unlimited logins
            return;
        }
        if (sessionCount == allowedSessions) {
            HttpSession session = request.getSession(false);
            if (session != null) {
                // Only permit it though if this request is associated with one of the
	             // already registered sessions
                for (SessionInformation si : sessions) {
                    if (si.getSessionId().equals(session.getId())) {
                        return;
                    }
                }
            }
        // If the session is null, a new one will be created by the parent class,
        // exceeding the allowed number
        }
    allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);
}
```

