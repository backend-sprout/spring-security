# CSRF 
CSRF는 기본적으로 권한을 탈취하는 해킹 기법이 아니다.  
오히려, 권한이 있거나 없어도 되는 가정하에 특정 작업을 처리하도록 하는 기법이다.    
     
![image](https://user-images.githubusercontent.com/50267433/150925333-6833e808-b1f4-4e36-8930-8d24be13259c.png)   

위 그림의 프로세스보다 원리에 대해서 설명해본다.  

1. 사용자는 특정 사이트에 로그인을 하면 세션쿠키를 발급받는다.   
2. 세션쿠키는 동일한 브라우저상에서 동작한다.    
3. 사용자가 공격 페이지에 접근하고, 공격 이미지를 클릭해서 특정 사이트에 요청을 보내도록한다.   
4. 동일한 브라우저에서 특정 사이트에 요청을 보낸것이기에 요청이 성공한다.   
5. 즉, 사용자도 모르게 특정 사이트에 특정 요청을 수행하도록 한 것이다.  
  
이 같은 원리를 이용해서 사용자의 비밀번호를 변경시키고     
해당 비밀번호를 통해서 아이디를 해킹할 수 있는 방식도 고려해볼 수 있다.      

1. 사용자는 특정 사이트로부터 로그인을 했다.
2. 해커가 사용자에게 피싱기법을 이용하여 특정 URL을 클릭하도록 유도한다.
3. 만약, 사용자가 해당 URL을 클릭하면 패스워드를 변경시키는 작업을 하도록한다.
4. 이후, 해커는 변경된 패스워드를 통해서 특정 사이트로 로그인하고 정보를 탈취한다.

## 해결법 
* Http Header 중 Referer 헤더를 체크하는 방식(단, 조작이 가능하다)   
* CSRF 방지 토큰 사용  

# 스프링 시큐리티의 CSRF 

스프링 시큐리티 또한, CSRF를 방지할 수 있는 기능들을 제공해주고 있다.   
    
## 동작    
  
**스프링 시큐리티는 `CsrfFilter`를 제공한다.**        
   
* 모든 요청에 랜덤하게 생성된 토큰을 HTTP 파라미터로 요구    
* 요청시 전달되는 토큰 값과 서버에 저장된 실제 값과 비교한 후 만약 일치하지 않으면 요청은 실패한다.  

![image](https://user-images.githubusercontent.com/50267433/150927081-a59a8771-4e5c-45d7-a80f-9993be738eeb.png)      

1. 사용자가 로그인과 같은 인증과정을 거치면, 스프링 시큐리티는 사용자에게 랜덤하게 생성된 토큰을 발급해준다.     
2. 사용자는 모든 요청에 해당 토큰을 HTTP 파라미터에 넣어야 한다.   
3. 만약, 토큰을 전달하지 못하게 된다면 접근 불가하다.                     
4. 또한, 요청시 전달되는 토큰값과 서버에 저장된 실제값을 비교하고 일치하지 않으면 실패 처리한다.     

## Rest api에서의 CSRF(disable 이유)    
  
Spring Security가 non-browser clients 만을 위한 서비스라면 csrf를 disable 하여도 좋다고 한다.(레퍼런스왈)   
           
RestAPI 로만 이루어진 서버라면, Stateless한 서버이기 때문에 **별도의 인증 정보를 보관하지 않아야한다.**                   
**만약, CSRF를 활성화하고 고가용성 및 로드밸런싱등의 이유로 서버를 여러개 둔다면?🤔**     
세션과 마찬가지로, CSRF 저장소를 DB로 만들거나해서 이들을 동기화하는 작업도 진행해야한다.   
즉, CSRF를 위해 복잡한 작업들은 수행해야한다는 의미이기도하다.    
   
이같은 문제로 인해, OAuth2, jwt토큰과 같은 필요한 인증 정보를 포함시켜서 전송하는 방식을 권장하고 있다.            
즉, 매 파라미터에 CSRF 토큰을 전송하는 불편한 코드는 더이상 상요하지 않아도 된다는 것이다.   
